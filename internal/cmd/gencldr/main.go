package main

import (
	"bytes"
	_ "embed"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"maps"
	"os"
	"slices"

	"golang.org/x/text/language"
)

// https://github.com/unicode-org/cldr-json/blob/main/cldr-json/cldr-core/supplemental/plurals.json
//
//go:embed plurals.json
var cardinalsJSON []byte

// https://github.com/unicode-org/cldr-json/blob/main/cldr-json/cldr-core/supplemental/ordinals.json
//
//go:embed ordinals.json
var ordinalsJSON []byte

type ModelVersion struct {
	UnicodeVersion string `json:"_unicodeVersion"`
	CLDRVersion    string `json:"_cldrVersion"`
}

type ModelCardinalSupplemental struct {
	Version              ModelVersion                `json:"version"`
	PluralsTypeCardinals map[string]ModelPluralRules `json:"plurals-type-cardinal"`
}

type ModelOrdinalSupplemental struct {
	Version             ModelVersion                `json:"version"`
	PluralsTypeOrdinals map[string]ModelPluralRules `json:"plurals-type-ordinal"`
}

type ModelPluralRules struct {
	Zero  string `json:"pluralRule-count-zero"`
	One   string `json:"pluralRule-count-one"`
	Two   string `json:"pluralRule-count-two"`
	Few   string `json:"pluralRule-count-few"`
	Many  string `json:"pluralRule-count-many"`
	Other string `json:"pluralRule-count-other"`
}

type ModelOrdinal struct {
	Supplemental ModelOrdinalSupplemental `json:"supplemental"`
}

type ModelCardinal struct {
	Supplemental ModelCardinalSupplemental `json:"supplemental"`
}

func main() {
	fOut := flag.String("out", "../cldr/cldr_gen.go", "Output Go file path")
	fPkgName := flag.String("pkgname", "cldr", "Output Go package name")
	flag.Parse()

	var ordinals ModelOrdinal
	if err := json.Unmarshal(ordinalsJSON, &ordinals); err != nil {
		panic(err)
	}

	var cardinals ModelCardinal
	if err := json.Unmarshal(cardinalsJSON, &cardinals); err != nil {
		panic(err)
	}

	f, err := os.OpenFile(*fOut, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o644)
	if err != nil {
		panic(err)
	}
	defer func() {
		if err := f.Close(); err != nil {
			fmt.Println("ERR:", err)
		}
	}()

	var buffer bytes.Buffer

	write(&buffer, *fPkgName, &cardinals, &ordinals)

	formatted, err := format.Source(buffer.Bytes())
	if err != nil {
		panic(err)
	}

	if _, err := f.Write(formatted); err != nil {
		panic(err)
	}
}

func write(
	w io.Writer, pkgName string, cardinals *ModelCardinal, ordinals *ModelOrdinal,
) {
	cardinalsKeys := slices.Sorted(
		maps.Keys(cardinals.Supplemental.PluralsTypeCardinals),
	)

	writef := func(format string, args ...any) {
		if _, err := fmt.Fprintf(w, format, args...); err != nil {
			panic(err)
		}
	}

	_ = cardinals
	_ = ordinals

	writef("// Generated by github.com/romshark/icumsg/internal/cmd/gencldr. " +
		"DO NOT EDIT.\n")
	writef("// CLDR Version: %s\n", cardinals.Supplemental.Version.CLDRVersion)
	writef("// Unicode Version: %s\n\n", cardinals.Supplemental.Version.UnicodeVersion)

	writef("package %s\n\n", pkgName)

	writef("import \"golang.org/x/text/language\"\n")

	writef("// Rules defines supported CLDR plural rules.\n")
	writef("type Rules struct { Zero, One, Two, Few, Many, Other bool }\n\n")

	writef("// PluralRules defines supported cardinal and ordinal CLDR plural rules.\n")
	writef("type PluralRules struct { Cardinal Rules; Ordinal Rules }\n\n")

	writef(
		"// PluralRulesByTag maps language tags to supported plural rules.\n",
	)
	writef("var PluralRulesByTag = make(map[language.Tag]PluralRules, %d)\n",
		len(cardinalsKeys))

	writef(
		"// PluralRulesByBase maps base languages to supported plural rules.\n",
	)
	writef("var PluralRulesByBase = make(map[language.Base]PluralRules, %d)\n",
		len(cardinalsKeys))

	writef("func init () {\n")
	writef("{\n")
	writef("PluralRulesByTag[language.Und] = PluralRules{\n")
	writef("\tCardinal: Rules{Other: true}, Ordinal: Rules{Other: true},\n")
	writef("}\n")
	writef("undBase, _ := language.Und.Base()\n")
	writef("PluralRulesByBase[undBase] = PluralRules{\n")
	writef("\tCardinal: Rules{Other: true}, Ordinal: Rules{Other: true},\n")
	writef("}\n")
	writef("}\n")
	writef("register := func(s string, cardinal, ordinal Rules, isBase bool) {\n")
	writef("l, err := language.Parse(s)\n")
	writef("if err != nil { panic(err) }\n")
	writef("PluralRulesByTag[l] = PluralRules {cardinal, ordinal}\n")
	writef("if isBase {\n")
	writef("\tbase, _ := l.Base()\n")
	writef("\tPluralRulesByBase[base] = PluralRules{cardinal, ordinal}")
	writef("}")
	writef("}\n")
	for _, k := range cardinalsKeys {
		fCardinal := cardinals.Supplemental.PluralsTypeCardinals[k]
		fOrdinal := ordinals.Supplemental.PluralsTypeOrdinals[k]
		if k == "und" {
			continue
		}

		base, _ := language.MustParse(k).Base()
		isBase := base.String() == k

		writef("register(%q,\nRules{Other: true,", k)
		// Cardinal.
		if fCardinal.Zero != "" {
			writef("Zero: true, ")
		}
		if fCardinal.One != "" {
			writef("One: true,")
		}
		if fCardinal.Two != "" {
			writef("Two: true,")
		}
		if fCardinal.Few != "" {
			writef("Few: true,")
		}
		if fCardinal.Many != "" {
			writef("Many: true,")
		}
		// Ordinal.
		writef("},\nRules{Other: true,")
		if fOrdinal.Zero != "" {
			writef("Zero: true, ")
		}
		if fOrdinal.One != "" {
			writef("One: true,")
		}
		if fOrdinal.Two != "" {
			writef("Two: true,")
		}
		if fOrdinal.Few != "" {
			writef("Few: true,")
		}
		if fOrdinal.Many != "" {
			writef("Many: true,")
		}
		writef("}, %t)\n", isBase)
	}
	writef("}\n\n")
	for _, k := range cardinalsKeys {
		rules := cardinals.Supplemental.PluralsTypeCardinals[k]
		l, err := language.Parse(k)
		if err != nil {
			panic(err)
		}
		_ = rules
		_ = l
	}
}
